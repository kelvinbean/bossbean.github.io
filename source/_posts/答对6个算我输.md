---
title: 答对6个算我输。
---

这些题是我之前很久写的一篇很简单的博文。现在拿出来炒冷饭。

感觉还是可以从中复习的一点小知识。

那么下面开始咯。

总共6道题。下面是答案，做完再看看。

<!-- More -->

## 问题

### 问题1

["1","2","3"].map(parseInt) 为多少？

### 问题2

console.log(0.1+0.2 == 0.3)  输出什么？

### 问题3

``` bash
    var a = b =10;
     (function(){
         var a = b = 20;
      })();
    console.log(a);
    console.log(b);
```

问：输出的 a = ?    b = ?


### 问题4

``` bash
    var i = j =0;
    for(;i<5,j<10;i++,j++){
          alert('helloword')
    }
```

问：请问输出多少个helloworld？

### 问题5

    isNaN(123) = ?
    isNaN('aaa') = ?

### 问题6

``` bash
    var name = 'Tom';
     function  a (){
          var name = 'Peter';
          return
          {
              name : name
          };
     }
```

问：a().name = ?





## 下面是答案

### 答案1

[1,NaN,NaN]

解析：

这题要了解map方法和parseInt这两个方法。
map 的一般使用是    arr.map(function(item,i){})
map的回调方法里面的第一个参数是键值，第二个参数是键名。
而parseInt这个方法也是有两个参数的，第二个参数是代表的是进制数。
当这个进制数不传或者传0的时候，默认为10进制。
所以这里面遍历的时候，传入的是数组的默认下标 0,1,2
所以遍历的结果是数组的第一个元素是可以正常显示。传入的键值为1，键名为0  输出1
而第二次  传入键值为2，键名为1  输出NaN  因为1进制的不可能会大于1的。
第三次传入键值为3，键名为2  输出了NaN  同样的，二进制是不会出现3的

### 答案2

false

解析：

这道题主要考你知不知道js的数字都是浮点数表示

下面一大串就是复制别人的解释的。

js中的数字都是用浮点数表示的，并规定使用IEEE 754 标准的双精度浮点数表示。
IEEE 754 规定了两种基本浮点格式：单精度和双精度。
IEEE单精度格式具有24 位有效数字精度(包含符号号)，并总共占用32 位。
IEEE双精度格式具有53 位有效数字精度(包含符号号)，并总共占用64 位。
十进制0.1    => 二进制0.00011001100110011…(循环0011)     =>尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-4（二进制移码为00000000010）,符号位为0    => 计算机存储为：0 00000000100 10011001100110011…11001    => 因为尾数最多52位，所以实际存储的值为0.00011001100110011001100110011001100110011001100110011001   
而十进制0.2    => 二进制0.0011001100110011…(循环0011)    =>尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-3（二进制移码为00000000011）,符号位为0    => 存储为：0 00000000011 10011001100110011…11001    因为尾数最多52位，所以实际存储的值为0.00110011001100110011001100110011001100110011001100110011
那么两者相加得：    0.00011001100110011001100110011001100110011001100110011001+  0.00110011001100110011001100110011001100110011001100110011    =  0.01001100110011001100110011001100110011001100110011001100 
转换成10进制之后得到:0.30000000000000004


所以出去做笔试的时候，题目如果说让你写一个浮点数相加的方法，你就不要直接写个return a+b 了。因为不会有人真的考这么简单的。。
解决方法可以使用升幂再降幂。以这道题为例的话。就是都先乘以10，相加后再除以10.。。如果是0.01+0.2那就都乘以100,以此类推。


### 答案3

a = 10     b = 20

解析：

这题考的就是连等的问题。所以说连等不要随便乱用。
连等赋值的时候，如a = b = c;
这个执行顺序从右往左。
就相当与b = c;a = b;
并不是 b=c; a = c;
所以回到题目。
一开始是var a = b = 10;
这个时候就是b = 10;var a = b; 所以a = 10; 因为js 的var声明不在严格模式下的话，是可以不用写的，因为b 不存在，所以也自动声明了。
之后再在一个立即执行函数里面，在这个作用域下执行了var a = b = 20;
就相当于b = 20 ;var a = b; 因为这时候b在全局外部已经声明了所以修改的就是全局的变量。
而a前面还有var ,所以这个a只是针对该作用域下的变量。并没有修改全局变量的a.
所以在全局外部打印a = 10   b = 20了。

### 答案4

10个

解析：

这题其实考得就是逗号运算符啦。。其实中间for循环是个逗号运算符。i<5,j<10 的计算结果其实就是j<10，所以打印10个。


### 答案5

false  true

解析：

这题就没什么好说的。
就是要知道isNaN这个函数的意义。
isNaN() 函数用于检查其参数是否是非数字值。
为数字时是false,
不为数字时是true
比较容易混淆。


### 答案6

报错，因为返回的是undefined.取undefined的name值会报错

解析：

这题就考细心了。。
为什么是报错?
因为你在return那里换行了啊。。
js末尾的 ; 经常是可以省略的。所以你这里进行换行了。就相当于return;
那后面的东西肯定也不会执行了。
所以不要乱换行。
